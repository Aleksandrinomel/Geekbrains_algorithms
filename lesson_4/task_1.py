# Lesson 2 task 4
# Найти сумму n элементов следующего ряда чисел: 1, -0.5, 0.25, -0.125, ...
# Количество элементов (n) вводится с клавиатуры.

import timeit
import cProfile


def summa(n):
    elem = 1
    sum_elements = 0
    for i in range(n):
        sum_elements += elem
        elem /= -2
    return sum_elements

s = """
def summa(n):
    elem = 1
    sum_elements = 0
    for i in range(n):
        sum_elements += elem
        elem /= -2
    return sum_elements
    
    
summa(10)
"""


# Для 10 время подсчета = 0.8610858190004365
# Для 20 время подсчета = 1.359455283999523
# Для 40 время подсчета = 2.28679022399956
# При увеличении кол-ва элементов в 2 раза, время нахождения суммы увеличивается приблизительно в 1.6 раз.
# Сложность O(n)


#print(timeit.timeit(s))
#print(summa(10))


def summa_2(n):
    return 1 * (1 -(-0.5) ** n) / (1 - (-0.5))


s_2 = """
def summa_2(n):
    return 1 * (1 -(-0.5) ** n) / (1 - (-0.5))
    
summa_2(10)
"""

#print(timeit.timeit(s_2))
# Для 10 время подсчета = 0.263576612000179
# Для 20 время подсчета = 0.26887032899867336
# Для 40 время подсчета = 0.27392226200026926
# При увеличении кол-ва элементов в 2 раза, время нахождения суммы увеличивается незначительно.
# Сложность O(1)


def summa_3(n):
    b = 1
    q = -0.5
    if n == 1:
        return n
    return (b * q ** (n-1)) + summa_3(n-1)


s_3 = """
def summa_3(n):
    b = 1
    q = -0.5
    if n == 1:
        return n
    return (b * q ** (n-1)) + summa_3(n-1)
    
    
summa_3(40)
"""

print(timeit.timeit(s_3))
# Для 10 время подсчета = 2.3985712229987257
# Для 20 время подсчета = 5.075814220999746
# Для 40 время подсчета = 10.408026746999894
# При увеличении кол-ва элементов в 2 раза, время нахождения суммы увеличивается в 2 раза.
# Сложность O(n)

# Вывод. Вариант №2 самый быстрый и экономный в плане памяти. Выполняется в одно действие не зависимо от кол-ва элементов.
# Вариант №1 Требует больше памяти для сохранения промежуточного результата. Время выполнения зависит от количества элементов.
# Вариант №3 Требует много памяти для сохранения текущего состояния каждого вызова функции. Время выполнения зависит от количества элементов.



